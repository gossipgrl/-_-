# Алхимки Средневековья владели знаниями о превращении различных химических веществ друг в друга. Это подтверждают и недавние 
# исследования археологов. В ходе археологических раскопок было обнаружено m глиняных табличек, каждая из которых была покрыта 
# непонятными на первый взгляд символами. В результате расшифровки выяснилось, что каждая из табличек описывает одну алхимическую 
# реакцию, которую умели проводить алхимики. Результатом алхимической реакции является превращение одного вещества в другое. 
# Заданы набор алхимических реакций, описанных на найденных глиняных табличках, исходное вещество и требуемое вещество. 
# Необходимо выяснить, возможно ли преобразовать исходное вещество в требуемое с помощью этого набора реакций, а в случае 
# положительного ответа на этот вопрос — найти минимальное количество реакций, необъодимое для осуществления такого преобразования.

# Формат ввода
# Первая строка входного файла содержит целое число m (0 ≤ m ≤ 1000) — количество записей в книге. Каждая из последующих m 
# строк описывает одну алхимическую реакцию и имеет формат вещество1 -> вещество2, где вещество1 — название исходного вещества, 
# вещество2 — название продукта алхимической реакции. m+2-ая строка входного файла содержит название вещества, которое имеется 
# исходно, m+3-ая — название вещества, которое требуется получить. Во входном файле упоминается не более 100 различных веществ. 
# Название каждого из веществ состоит из строчных и заглавных латинских букв и имеет длину не более 20 символов. Строчные и 
# заглавные буквы различаются

# Формат вывода
# В выходной файл выведите минимальное количество алхимических реакций, которое требуется для получения требуемого вещества из 
# исходного, или -1, если требуемое вещество невозможно получить.

def minimum_reactions(reactions, start, end):
    graph = {}
    for reaction in reactions:
        src, dst = reaction.split(' -> ')
        if src not in graph:
            graph[src] = []
        graph[src].append(dst)

    visited = set()
    queue = [(start, 0)]

    while queue:
        current, count = queue.pop(0)
        if current == end:
            return count

        visited.add(current)
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                queue.append((neighbor, count + 1))

    return -1


m = int(input())
reactions = [input() for _ in range(m)]
start = input()
end = input()

result = minimum_reactions(reactions, start, end)
print(result)