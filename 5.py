# Суровые феодальные времена переживала некогда великая островная страна Байтландия. За главенство над всем островом борются 
# два самых сильных барона. Таким образом, каждый город страны контролируется одним из правителей. Как водится издревле, 
# некоторые из городов соединены двусторонними дорогами. Бароны очень не любят друг друга и стараются делать как можно больше 
# пакостей. В частности, теперь для того чтобы пройти по дороге, соединяющей города различных правителей, надо заплатить 
# пошлину — один байтландский рубль.Программист Вася живет в городе номер 1. С наступлением лета он собирается съездить в город N
# на Всебайтландское сборище программистов. Разумеется, он хочет затратить при этом как можно меньше денег и помочь ему здесь, 
# как обычно, предлагается Вам.

# Формат ввода
# В первой строке входного файла записано два числа N и M (1≤N,M≤100000) — количество городов и количество дорог соответсвенно.
# В следующий строке содержится информация о городах — N чисел 1 или 2 — какому из баронов принадлежит соответствующий город.
# В последних M строках записаны пары 1≤a,b≤N, a≠b. Каждая пара означает наличие дороги из города a в город b. По дорогам 
# Байтландии можно двигаться в любом направлении.

# Формат вывода
# Если искомого пути не существует, выведите единственное слово impossible. В противном случае в первой строке 
# напишите минимальную стоимость и количество посещенных городов, а во вторую выведите эти города в порядке посещения. 
# Если минимальных путей несколько, выведите любой.

import heapq
def read_input():
    N, M = map(int, input().split())
    barons = list(map(int, input().split()))
    roads = [list(map(int, input().split())) for _ in range(M)]
    return N, M, barons, roads
def dijkstra(N, barons, roads):
    graph = [[] for _ in range(N + 1)]
    for a, b in roads:
        graph[a].append(b)
        graph[b].append(a)
    queue = [(0, 1, [1])]
    visited = [False] * (N + 1)
    while queue:
        cost, node, path = heapq.heappop(queue)
        if visited[node]:
            continue
        visited[node] = True

        if node == N:
            return cost, path

        for neighbor in graph[node]:
            if not visited[neighbor]:
                new_cost = cost
                if barons[node - 1] != barons[neighbor - 1]:
                    new_cost += 1
                heapq.heappush(queue, (new_cost, neighbor, path + [neighbor]))
    return -1, []

N, M, barons, roads = read_input()
cost, path = dijkstra(N, barons, roads)
if cost == -1:
    print("impossible")
else:
    print(f"{cost} {len(path)}")
    print(" ".join(map(str, path)))